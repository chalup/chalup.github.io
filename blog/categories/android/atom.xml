<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Porcupine Programmer]]></title>
  <link href="http://chalup.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://chalup.github.io/"/>
  <updated>2014-09-05T22:38:26+02:00</updated>
  <id>http://chalup.github.io/</id>
  <author>
    <name><![CDATA[Jerzy Chalupski]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[My Shortest-lived Project Ever]]></title>
    <link href="http://chalup.github.io/blog/2014/09/04/my-shortest-lived-project-ever/"/>
    <updated>2014-09-04T21:11:06+02:00</updated>
    <id>http://chalup.github.io/blog/2014/09/04/my-shortest-lived-project-ever</id>
    <content type="html"><![CDATA[<p>Three weeks ago I wrote a <a href="https://github.com/chalup/proguard-please">proguard-please</a> plugin. I was super excited by this project because:</p>

<ol>
<li>It was a Gradle plugin, something I wanted to play with for quite some time</li>
<li>It was written in Groovy, a language I wanted to play with for quite some time</li>
<li>It solved a real issue with ProGuard configuration, which was pissing me off for quite some time</li>
</ol>


<h2>On configuring ProGuard</h2>

<p>If you&rsquo;re not familiar with ProGuard, here&rsquo;s the basic info: it&rsquo;s a program which prunes the unused code from your compiled Java program. It can also do other stuff like optimization or code obfuscation and repackaging to make the reverse engineering harder. Sounds good? The catch is that ProGuard sometimes cuts out or obfuscates too much code, which usually breaks the app, especially if you rely on reflection. The trick is to configure it correctly for each library you use, but it&rsquo;s not a trivial task.</p>

<p>The general idea for this plugin was to resolve the dependencies of your Android application and try to find the ProGuard configuration for every one of them. Of course the ProGuard config will not magically appear: the idea was to have a repository of configurations developed by the community.</p>

<h2>On Gradle</h2>

<p>First part of the project went really smooth, thanks to the <a href="http://www.gradle.org/docs/current/userguide/userguide.html">amazing documentation</a>. I didn&rsquo;t need to do any fancy stuff, so I was able to configure the basic scaffolding in no time at all. Docs for android gradle plugin are pretty much non-existent, but using the imported sources and <a href="https://bitbucket.org/hvisser/android-apt">android-apt</a> plugin by <a href="https://twitter.com/botteaap">Hugo Visser</a> as a base for Android related tasks I was able to get my plugin up and running.</p>

<h2>On Groovy</h2>

<p>I saw the Groovy for the first time at KrakDroid conference, when <a href="https://github.com/wojtekerbetowski">Wojciech Erbetowski</a> converted boring JUnit tests into <a href="https://github.com/Polidea/RoboSpock">RoboSpock</a> goodness. It looked nice, but when I started coding in Groovy, my love for this language faded.</p>

<p>There are lot of things I take for granted as a Java developer: amazing IDE, instant feedback when I screw something up and documentation for the code under my cursor at my fingertips. Maybe switching to Groovy, Ruby or Python requires some mindset change I haven&rsquo;t fully embraced, but I simply cannot imagine why would I switch to the language that effectively forces me to write my code in Notepad™.</p>

<p>I think the main problem I have with Groovy stems for the fact that there are some APIs that wouldn&rsquo;t typecheck in regular Java. Consider this code:</p>

<p>```groovy
if (!project.android[&ldquo;productFlavors&rdquo;].isEmpty()) {</p>

<pre><code>throw new ProjectConfigurationException("The build flavors are not supported yet", null)
</code></pre>

<p>}</p>

<p>def obfuscatedVariants = project.android[&ldquo;applicationVariants&rdquo;].findAll { v &ndash;> v.obfuscation != null }
```</p>

<p>It&rsquo;s a classic type of what I call &ldquo;string typing&rdquo;: depending on the key used in <code>project.android[]</code> access you get collection of objects of completely different type. As a consequence, the IDE cannot provide you with autocompletion or documentation for the collection contents.</p>

<p>Another example is the public API of Grgit library. Theoretically you can call <code>Grgit.clone(...)</code>, but there is no such method as <code>clone</code> in <code>Grgit</code> class, instead you have this code:</p>

<p>```groovy
class Grgit {</p>

<pre><code>private static final Map STATIC_OPERATIONS = [init: InitOp, clone: CloneOp]

static {
    Grgit.metaClass.static.methodMissing = { name, args -&gt;
        OpSyntaxUtil.tryOp(Grgit, STATIC_OPERATIONS, [] as Object[], name, args)
    }
}
</code></pre>

<p>} <br/>
```</p>

<p>I don&rsquo;t see what&rsquo;s wrong with the good ol' static method and what do you achieve by using <code>methodMissing</code> (besides confusing the IDE and breaking autocomplete/javadocs). Maybe I&rsquo;m just grupy old fart with brain eroded by too long exposure to Java, but Groovy is definitely not a language for me. I&rsquo;ll put up with it if I ever want to write another gradle plugin, but it&rsquo;s not going to be my go to language.</p>

<h2>What&rsquo;s up with the blog title?</h2>

<p>Few hours after publishing my project, another solution for ProGuard configuration appeared. It turns out, if you use gradle to build your library, you can configure <code>consumerProguardFiles</code> property to include in your aar package a ProGuard configuration that should be used by the users of your library. The logical next step is creating the library project containing only the ProGuard configuration for the most popular libraries out there. And that&rsquo;s exactly what <a href="https://bitbucket.org/littlerobots/squadleader">squadleader</a> project is.</p>

<p>It&rsquo;s not as flexible solution as my <a href="https://github.com/chalup/proguard-please">proguard-please</a> plugin, but it&rsquo;s much simpler, much easier to contribute to and the net effect is the same. In this light I chose to put my project on hold and redirect developers to squadleader page.</p>

<p>Despite of that, I&rsquo;m glad I worked on this project. I&rsquo;m very excited by the fact that you can easily build an useful tool that&rsquo;s incredibly easy to use. Using gradle for a new build system was a great call.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Recent Apps List and Intent Extras]]></title>
    <link href="http://chalup.github.io/blog/2014/07/03/android-recent-apps-list-and-intent-extras/"/>
    <updated>2014-07-03T22:14:06+02:00</updated>
    <id>http://chalup.github.io/blog/2014/07/03/android-recent-apps-list-and-intent-extras</id>
    <content type="html"><![CDATA[<p>If you&rsquo;re programming for the same platform for some time, you have probably developed some habits. You do some stuff in a particular way, because you&rsquo;ve always done it this way. It might be a good thing if you know all pros and cons of your solution, because your code will be consistent and you don&rsquo;t waste time rethinking the same things over and over again. On the other hand it is a good practice to question this established ways of doing things from time to time &ndash; maybe you&rsquo;ve missed something when you thought about this last time or some of your arguments are no longer valid.</p>

<p>For me one of such things was the <code>Serializable</code> vs. <code>Parcelable</code> conundrum. A long time ago I read somewhere that <code>Serializable</code> is much slower than <code>Parcelable</code> and it shouldn&rsquo;t be used for large objects, but it&rsquo;s fast enough for passing simple POJOs between <code>Fragments</code> and <code>Activities</code> with <code>Intent</code> or arguments <code>Bundle</code>. While this is still a generally good advice, I realized I don&rsquo;t know how much faster the <code>Parcelable</code> is. Are we looking at 10µs vs. 15µs or 10µs vs. 10ms?</p>

<p>I&rsquo;m too lazy to write a benchmark myself, but I found a <a href="http://www.developerphil.com/parcelable-vs-serializable/">decent article</a>. Tl;dr: on modern hardware (Nexus 4) serializing a simple data structure takes about 2ms and using <code>Parcelable</code> is about 10 times faster.</p>

<p>Another hit on Google was a <a href="http://www.reddit.com/r/androiddev/comments/1daiib/parcelable_vs_serializable/">reddit thread</a> for this article. I found there an interesting comment by <a href="https://plus.google.com/u/1/+JakeWharton">+Jake Wharton</a>:</p>

<p><blockquote><p>Serializable is like a tattoo. You are committing to a class name, package, and field structure forever. The only way to &ldquo;remove&rdquo; it is epic deserialization hacks.</p></p><p><p>Yes using it in an Intent isn&rsquo;t much harm, but if you use serialization there&rsquo;s a potential for crashing your app. They upgrade, hit your icon on the launcher, and Android tries to restore the previous Intent for where they were at in your app. You changed the object so deserialization fails and the app crashes. Not a good upgrade experience. Granted this is rare, but if you ever persist something to disk like this it can leave you in an extremely bad place.</p></blockquote></p>

<p>There are two inaccuracies in the comment above. First, the problem will happen only if the app is started from the recet apps list, not from the launcher icon. Second, the problem is not limited to <code>Serializable</code> extras: <code>Parcelable</code> might read the byte stream originally written from a different structure (in this situation crash is a best case scenario), some extras might be missing, some might hold wrong type of data.</p>

<p>Can you prevent this issue? I don&rsquo;t think so, at least not without some sophisticated validation of Intent extras. Considering that this issue is very rare and it goes away after starting the faulty app from somewhere else than recent apps list I don&rsquo;t think you should spend any time trying to fix it, but it&rsquo;s good to know about it, as it might explain some WTF crash reports coming your way.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google I/O 2014 Summary]]></title>
    <link href="http://chalup.github.io/blog/2014/06/27/google-i-slash-o-2014-summary/"/>
    <updated>2014-06-27T21:34:11+02:00</updated>
    <id>http://chalup.github.io/blog/2014/06/27/google-i-slash-o-2014-summary</id>
    <content type="html"><![CDATA[<p>Here are my thoughts after watching the keynote and few Android related sessions.</p>

<h2>Highlights</h2>

<h3>Android One</h3>

<p>This might be a huge, not only because it means expanding the potential user base for your apps. The most important thing is that all these new devices will run the latest Android and software updates will be provided by Google. If this kind of support becomes standard, we might be able to use <code>minSdkVersion=20</code> pretty soon.</p>

<h3>ART</h3>

<p>The Dalvik was decomissioned, the new runtime is the only runtime. I do hope this means that the 64k method limit is no longer a problem and there are no technical roadblocks for Java 8 support. Maybe this questions were answersed during <a href="https://www.google.com/events/io/schedule/session/b750c8da-aebe-e311-b297-00155d5066d7">The ART runtime</a> session, unfortunately there was no live stream of it.</p>

<p><strong>Edit</strong>: the video from the session is available. The GC improvements and performance boosts are amazing, but if I understand everything correctly the ART still uses dex bytecode underneath, so all Dalvik limitations are still in place.   Bad Google.</p>

<h3><a href="https://plus.google.com/+XavierDucrohet/posts">+Xavier Ducrohet</a></h3>

<p>I got the feeling that he&rsquo;s the only Google employee who acknowledges that there are serious issues with developing on Android. Great answers about unit tests and robolectric support, good answer about Scala support.</p>

<h2>Dunno what to make of it</h2>

<h3>RecyclerView</h3>

<p><code>ListViews</code> are far from perfect. I know, because in our codebase we have few workarounds for the issues or poor APIs. It&rsquo;s good that something more flexible is available, it&rsquo;s great that it&rsquo;s a part of support library, but some parts of the <code>RecyclerView</code> API look incredibly complex.</p>

<h3>Unlock bypass with Wear device</h3>

<p>Call me paranoid, but this feature means that if I get mugged, I&rsquo;m totally screwed. Someone gets access to my email, and through that he gets access to every piece of my data on the web and my digital idendity. Thanks, I&rsquo;ll pass.</p>

<p>On the other hand there are users who do not use pin or pattern on the lockscreens. For these people, this feature is a significant security improvement.</p>

<h2>Lowlights</h2>

<h3>Always running, big-ass TVs</h3>

<p>During keynote one speaker mentioned that in average household the TV is on for 5 hours every day and suggested that for the other 19 hours it can be used as a digital canvas for your content. I&rsquo;m not sure if encouraging people to keep the huge, power hungry device all the time to display nice pictures is very thoughtful and enviromentally aware.</p>

<h3>Fireside chat</h3>

<p>There were some über lame questions from the audience, but that&rsquo;s expected when questions are not moderated. However there were also über lame answers for valid questions, and there is no excuse for it.</p>

<p>The very first question, about Java 8 support, was answered with smirks and a slimy answer from Chet Haase. Dear Google, after WWDC the Java 8 support is no longer a huge news, so if you&rsquo;re saving it for the future, don&rsquo;t bother. And if there are any issues with Java 8 support &ndash; legal, technical, whatever &ndash; just let the developers know.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[minSdkVersion=15, What's Next?]]></title>
    <link href="http://chalup.github.io/blog/2014/06/15/minsdkversion-equals-15/"/>
    <updated>2014-06-15T09:29:50+02:00</updated>
    <id>http://chalup.github.io/blog/2014/06/15/minsdkversion-equals-15</id>
    <content type="html"><![CDATA[<p>A year ago <a href="https://twitter.com/readyState">Jeff Gilfelt</a> was giving away <code>minSdkVersion=14</code> stickers, promoting the idea of dumping the support for Gingerbread and Honeycomb. What seemed radical one year ago, today is a widely accepted. The <code>minSdkVersion</code> in new project wizard in latest Android Studio release is by default set to <code>15</code>. On the same screen you can click the &ldquo;help me choose&rdquo; hyperlink, which shows this screen:</p>

<p><img class="center" src="/images/android_studio_min_sdk.png"></p>

<p>The percentages are consistent with data from <a href="http://developer.android.com/about/dashboards/index.html">developer.android.com</a> dashboards, but I&rsquo;d say they are skewed towards old Android versions. <a href="https://play.google.com/store/apps/details?id=com.futuresimple.base">Base CRM</a> app I&rsquo;m working on has only 3.7% active users on devices with api level &lt; 15 (compared to 17.4% from official Google dashboards). Moreover, if you look only at the new users, the Froyo, GingerBread and Honeycomb is used only by 1%. In this light, supporting pre-API15 devices is a criminal waste, and starting new projects with minSdkVersion lower than 15 a criminal idiocy.</p>

<p>For me, as a delevoper, the <code>minSdkVersion=14</code> is a breakthrough, mostly because of Holo theme available everywhere. I no longer have to worry about <a href="http://localhost:4000/blog/2012/03/08/customizing-ui-controls-on-android/">HTC rounded green buttons and such when creating custom views</a> &ndash; I only have to make them look good with a single theme. Theoretically one could have used <a href="https://github.com/Prototik/HoloEverywhere">HoloEverywhere lib</a>, but it&rsquo;s not a drop-in replacement. First you have to switch to using their Views instead of native ones and adjusting any external UI library to use them as well.</p>

<p>I looked through the <a href="https://developer.android.com/about/index.html">Android changelogs</a> wondering what could be the next version on <code>minSdkVersion</code> stickers. The next step is a small bump to JellyBean (API level 16), which gives us access to actions in system notifications and <code>condensed</code> and <code>light</code> Roboto font variants. Official statictics state that Ice Cream Sandwich is used by 12.3% of users, but this number is much higher than the one from Base statistics &ndash; 5.87%. I expect dropping support for ICS this year.</p>

<p>But then? I don&rsquo;t see anything as groundbreaking as dropping Gingerbread. I don&rsquo;t even see anything with more impact than dropping ICS. Theoretically API level 17 gives access to nested fragments, but I think you should be using support-v4 classes anyways (and if you check the <a href="https://play.google.com/store/apps/details?id=com.google.samples.apps.iosched">Google I/O 2014</a> app sources, Google developers seem to think so too). Maybe there&rsquo;s something I missed or something crucial for specific use cases &ndash; do let me know if there&rsquo;s anything in API levels 17-19 you wish you could use already.</p>

<p>Google I/O is coming though, and <a href="https://twitter.com/GabMarioPower/status/477040313832583168">some things indicate</a> we might see Android 5.0 (or at least Android 4.5). Maybe this Android &ldquo;L&rdquo; version will be another breakthrough in development? My personal wish is a new runtime without <a href="https://code.google.com/p/android/issues/detail?id=20814">ridiculous 64k method limit</a>. Of course this opens a lot of other possibilities. Maybe support for Java 8? Or first-class support for other JVM languages? We&rsquo;ll see&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Loaders]]></title>
    <link href="http://chalup.github.io/blog/2014/06/12/android-loaders/"/>
    <updated>2014-06-12T21:52:43+02:00</updated>
    <id>http://chalup.github.io/blog/2014/06/12/android-loaders</id>
    <content type="html"><![CDATA[<p>If you fetch the data from any <code>ContentProvider</code> in your application, the most likely scenarios are:</p>

<ol>
<li>You&rsquo;re absolutely clueless and fetch the data on UI thread.</li>
<li>You&rsquo;re using an <code>AsyncTask</code> and:

<ul>
<li>Your app crashes on screen orientation change.</li>
<li>You block the screen orientation, because you googled this &ldquo;solution&rdquo; on StackOverflow.</li>
<li>You wrote error prone boilerplate code to detach and reattach the <code>AsyncTask</code> from the Activity.</li>
</ul>
</li>
<li>You are using <code>CursorLoader</code>.</li>
</ol>


<p>But accessing <code>ContentProvider</code> is probably not the only type of asynchronous operations you perform. You might want to access <code>SharedPreferences</code>, read a file or query a web API. In that case you need <code>Loader&lt;SomeOtherDataThanCursor&gt;</code>, but implementing one correctly is a bit tricky.</p>

<p>I&rsquo;ll walk you through the entire process of understanding how the Loaders work, implementing a sane base class for your Loaders, implementing <code>CursorLoader</code> with all issues fixed and extending it to allow multiple notification Uris. It&rsquo;ll be a long post so grab a cup of your favourite beverage.</p>

<h2>Loaders 101</h2>

<p>Loader should do three things:</p>

<ol>
<li>Load data in background thread.</li>
<li>Cache the loaded data, so you won&rsquo;t reload it after screen orientation change.</li>
<li>If applicable, monitor the data source and reload the data when necessary.</li>
</ol>


<p>The Loader class itself doesn&rsquo;t provide any mechanism for loading the data in background thread. You either have to implement this yourself, or you can subclass the <code>AsyncTaskLoader</code>. This covers the first point on our requirements list.</p>

<p>The 2nd point is not handled by <code>AsyncTaskLoader</code>. In fact the <code>AsyncTaskLoader</code> is far from being fully functional, for example this perfectly reasonable looking implementation won&rsquo;t work:</p>

<p>``` java
public class DasLoader extends AsyncTaskLoader<String> {
  public DasLoader(Context context) {</p>

<pre><code>super(context);
</code></pre>

<p>  }</p>

<p>  @Override
  public String loadInBackground() {</p>

<pre><code>return "Das";
</code></pre>

<p>  }
}
```</p>

<h2>AbstractLoader v1</h2>

<p>A good starting point for creating either <code>CursorLoader</code> implementation or LoaderCustom.java from SDK samples. Here&rsquo;s the common part of these two implementations, which provides all necessary boilerplate for loading and caching the data:</p>

<p>``` java
public abstract class AbstractLoader<T> extends AsyncTaskLoader<T> {
  T mResult;</p>

<p>  public AbstractLoader(Context context) {</p>

<pre><code>super(context);
</code></pre>

<p>  }</p>

<p>  @Override
  public void deliverResult(T result) {</p>

<pre><code>if (isReset()) {
  releaseResources(result);
  return;
}

T oldResult = mResult;
mResult = result;

if (isStarted()) {
  super.deliverResult(result);
}

if (oldResult != result &amp;&amp; oldResult != null) {
  releaseResources(oldResult);
}
</code></pre>

<p>  }</p>

<p>  @Override
  public void onCanceled(T result) {</p>

<pre><code>super.onCanceled(result);
releaseResources(result);
</code></pre>

<p>  }</p>

<p>  @Override
  protected void onReset() {</p>

<pre><code>super.onReset();

// Ensure the loader is stopped
onStopLoading();

releaseResources(mResult);
mResult = null;
</code></pre>

<p>  }</p>

<p>  @Override
  protected void onStartLoading() {</p>

<pre><code>if (mResult != null) {
  deliverResult(mResult);
}
if (takeContentChanged() || mResult == null) {
  forceLoad();
}
</code></pre>

<p>  }</p>

<p>  @Override
  protected void onStopLoading() {</p>

<pre><code>cancelLoad();
</code></pre>

<p>  }</p>

<p>  protected void releaseResources(T result) {
  }
}
```</p>

<p>Why this class is not provided by the framework is a mystery to me, but hey, that&rsquo;s just one more thing you have to know when coding for Android platform. Now you can write your custom Loader like this:</p>

<p>``` java
public class DasLoader extends AbstractLoader<String> {
  public DasLoader(Context context) {</p>

<pre><code>super(context);
</code></pre>

<p>  }</p>

<p>  @Override
  public String loadInBackground() {</p>

<pre><code>return "Das";
</code></pre>

<p>  }
}
```</p>

<p>But why do we need all that code? The key to understanding the Loaders is understanding the expected Loader&rsquo;s behaviour in different states: started, stopped, abandoned and reset. Upon entering each state, the appropriate callback is executed:</p>

<ul>
<li><code>onStartLoading</code>: the Loader was created and should either load the data or return cached data.</li>
<li><code>onStopLoading</code>: the Loader should keep the cached data and monitor the data source for changes, but it shouldn&rsquo;t load the data. This happens for example when users presses home button from your app.</li>
<li><code>onAbandoned</code>: someone restarted the Loader. New instance of this Loader was created in <code>onCreateLoader</code> callback in your <code>Fragment</code>/<code>Activity</code>/whatever and loads new data. The abandoned Loader should keep the data until the new Loader loads and delivers it&rsquo;s data. There is no point of monitoring data source or reloading the data in abandoned Loader &ndash; the data will be loaded by the new instance. When new Loader delivers it&rsquo;s data this Loader will be reset.</li>
<li><code>onReset</code>: the data previously loaded by this Loader are no longer used and should be cleaned up. This Loader might be started again, so make sure you clean up also any old state in your Loader implementation.</li>
</ul>


<p>The <code>AsyncTaskLoader</code> provides additional callback:</p>

<ul>
<li><code>onCancelled</code>: called after data loading when it turns out that this data is no longer needed, for example when the <code>AsyncTask</code> executing your <code>onLoadInBackground</code> was cancelled. In this callback you should take care of releasing resources.</li>
</ul>


<p>Since the releasing resources should be also performed in <code>onReset</code> callback and in our deliverResults implementation, our AbstractLoader class provides handy <code>releaseResources()</code> callback for closing your <code>Cursor</code>s, file handles, etc.</p>

<p>Now let&rsquo;s walk through our <code>AbstractLoader</code> implementation. When someone starts our Loader using <code>LoaderManager.initLoader()</code>, the <code>onStartLoading</code> is called:</p>

<p>``` java
  T mResult;</p>

<p>  // &hellip;</p>

<p>  @Override
  protected void onStartLoading() {</p>

<pre><code>if (mResult != null) {
  deliverResult(mResult);
}
if (takeContentChanged() || mResult == null) {
  forceLoad();
}
</code></pre>

<p>  }
```</p>

<p>We keep the loaded data in <code>mResult</code> member of our <code>AbstractLoader</code>. If we have already loaded the data, we can just deliver the results to Loader clients. If the cache is empty or the Loader was notified about new data available for fetching, we force data reload by calling <code>forceLoad()</code> method. It starts <code>AsyncTask</code> which executes <code>loadInBackground</code> in background thread and the result is passed to <code>deliverResults</code> function:</p>

<p>``` java
  @Override
  public void deliverResult(T result) {</p>

<pre><code>if (isReset()) {
  releaseResources(result);
  return;
}

T oldResult = mResult;
mResult = result;

if (isStarted()) {
  super.deliverResult(result);
}

if (oldResult != result &amp;&amp; oldResult != null) {
  releaseResources(oldResult);
}
</code></pre>

<p>  }
```</p>

<p>A lot of interesting things happen here. First, we check if the loader was put into <code>reset</code> state. In this state all the previous resources were already released, so we just need to take care of newly loaded data. Then we swap the data in cache, call <code>deliverResults</code> in Loader and then release the resources for previously cached data.</p>

<p>When the Fragment or Activity with active Loader is stopped, the Loaders are also put in the stopped state. It means that they should keep the cached data, monitor if this data is still valid, but they should not actively load the data or deliver the results to UI thread. In terms of <code>AsyncTaskLoader</code> it means that any running <code>AsyncTasks</code> should be cancelled:</p>

<p>``` java
  @Override
  protected void onStopLoading() {</p>

<pre><code>cancelLoad();
</code></pre>

<p>  }
```</p>

<p>Current implementation of <code>AsyncTaskLoader</code> do not interrupt the active tasks, it only marks that the results of these tasks should not be delivered to the UI thread. However, the results might require some resource releasing, so the <code>onCancelled</code> callback is called:</p>

<p>``` java
  @Override
  public void onCanceled(T result) {</p>

<pre><code>super.onCanceled(result);
releaseResources(result);
</code></pre>

<p>  }
```</p>

<p>The last callback we have to implement is <code>onReset</code>:</p>

<p>```java
  @Override
  protected void onReset() {</p>

<pre><code>super.onReset();

// Ensure the loader is stopped
onStopLoading();

releaseResources(mResult);
mResult = null;
</code></pre>

<p>  }
```</p>

<p>There are two important things here. First, the Loader can be moved to reset state from started state, which means it can still have active <code>AsyncTasks</code> executing <code>loadInBackground</code>. We need to stop them first. Then, as per the specified contract, we have to release the resources and clear the cache.</p>

<p>What about <code>onAbandoned</code> callback? AbstractLoader doesn&rsquo;t monitor any data source by itself, so this callback doesn&rsquo;t have to be implemented.</p>

<h2>CursorLoader</h2>

<p>So how would we implement observing a data source and automatic reloading? Let&rsquo;s see how would the <code>CursorLoader</code> implementation look like had we used our AbstractLoader as a base class (literally; if you merge MyCursorLoader and AbstractLoader code samples from this post, you&rsquo;ll get exactly the CursorLoader implementation from support-v4):</p>

<p>```java
public class MyCursorLoader extends AbstractLoader<Cursor> {
  private final ForceLoadContentObserver mObserver;</p>

<p>  public MyCursorLoader(Context context) {</p>

<pre><code>super(context);
mObserver = new ForceLoadContentObserver();
</code></pre>

<p>  }</p>

<p>  // bunch of setters for uri, projection, selection, etc. Omitted for brevity</p>

<p>  @Override
  public Cursor loadInBackground() {</p>

<pre><code>Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection,
    mSelectionArgs, mSortOrder);
if (cursor != null) {
  // Ensure the cursor window is filled
  cursor.getCount();
  cursor.registerContentObserver(mObserver);
}
return cursor;
</code></pre>

<p>  }
}
```</p>

<p>This implementation has two bugs and one kind-of-feature. Let&rsquo;s start with the last one.</p>

<p><code>onStartLoading</code> contract specifies, that you should start monitoring the data source upon entering this state. But let&rsquo;s think what would happen if you had a query that takes 200ms to run and your data source would change every 150ms. The loader would never deliver any data, because every load request would be cancelled in middle of <code>loadInBackground</code> execution by our content observer.</p>

<p>I guess that&rsquo;s why the Android implementation of <code>CursorLoader</code> registers the observer after the data is loaded. This way the first results are delivered as soon as possible, but for subsequent loads the data is delivered only when data didn&rsquo;t change during loading. I&rsquo;m not sure if it was intentional, or this behavior was implemented by accident, but it makes sense to me, so let&rsquo;s adjust our Loaders contract and implement this behavior in our AbstractLoader.</p>

<p>But if you look closely, the <code>CursorLoader</code> implementation violates even this updated contract. Remember that <code>loadInBackground</code> and <code>deliverResults</code> are executed on separate threads. So what would happen if the data observer is triggered after <code>registerContentObserver</code> call, but before the <code>deliverResults</code>? We&rsquo;d get exactly the same behavior we&rsquo;d get had we registered the ContentObserver in <code>onStartLoading</code> &ndash; the loader would never deliver it&rsquo;s data. That&rsquo;s the first bug.</p>

<p>The second issue with <code>CursorLoader</code> implementation is violation of <code>onAbandon</code> callback contract. If someone calls restartLoader and the content observer is triggered, the abandoned Loader instance will happily reload it&rsquo;s data just to throw it away.</p>

<p>You can dismiss it as something that would happen only 1% of the time and has negligible impact, and if we were talking about application code, I&rsquo;d agree with you, but IMO library code that will be used by thousands of developers should be held to a higher standard.</p>

<h2>Fixing CursorLoader</h2>

<p>Here&rsquo;s the wrap up of changes in behavior:
1. Register <code>ContentObserver</code> after the first data is delivered, not after the first data is loaded.
2. Unregister <code>ContentObserver</code> in <code>onAbandon</code>.</p>

<p>The first point requires changes to <code>deliverResult</code> method, so it makes sense to modify our AbstractLoader:</p>

<p>``` java
  @Override
  public void deliverResult(T result) {</p>

<pre><code>if (isReset()) {
  releaseResources(result);
  return;
}

T oldResult = mResult;
mResult = result;

if (isStarted()) {
  if (oldResult != result) {
    onNewDataDelivered(result);
  }
  super.deliverResult(result);
}

if (oldResult != result &amp;&amp; oldResult != null) {
  releaseResources(oldResult);
}
</code></pre>

<p>  }</p>

<p>  protected void onNewDataDelivered(T data) {
  }
```</p>

<p>Our <code>CursorLoader</code> implementation would look like this:</p>

<p>``` java
public class MyCursorLoader extends AbstractLoader<Cursor> {
  private final ForceLoadContentObserver mObserver;</p>

<p>  public MyCursorLoader(Context context) {</p>

<pre><code>super(context);
mObserver = new ForceLoadContentObserver();
</code></pre>

<p>  }</p>

<p>  // bunch of setters for uri, projection, selection, etc. Omitted for brevity</p>

<p>  @Override
  public Cursor loadInBackground() {</p>

<pre><code>Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection,
    mSelectionArgs, mSortOrder);
if (cursor != null) {
  // Ensure the cursor window is filled
  cursor.getCount();
}
return cursor;
</code></pre>

<p>  }</p>

<p>  @Override
  protected void onNewDataDelivered(Cursor data) {</p>

<pre><code>super.onNewDataDelivered(data);
data.registerContentObserver(mObserver);
</code></pre>

<p>  }
}
```</p>

<p>The second part &ndash; unregistering observer in <code>onAbandon</code> &ndash; is tricky. It&rsquo;s illegal to call <code>Cursor.unregisterContentObserver</code> with observer that wasn&rsquo;t registered and the <code>onAbandon</code> can be called when the <code>deliverResults</code> wasn&rsquo;t called (see <code>AsyncTaskLoader.dispatchOnLoadComplete()</code> implementation). One solution would be keeping the set of Cursors that were registered, but it&rsquo;s not optimal. Instead, we can create a proxy ContentObserver that can be enabled or disabled:</p>

<p>``` java
public class DisableableContentObserver extends ContentObserver {
  private final ContentObserver mWrappedObserver;
  private boolean mIsEnabled = true;</p>

<p>  public DisableableContentObserver(ContentObserver wrappedObserver) {</p>

<pre><code>super(new Handler());
mWrappedObserver = wrappedObserver;
</code></pre>

<p>  }</p>

<p>  @Override
  public void onChange(boolean selfChange) {</p>

<pre><code>if (mIsEnabled) {
  mWrappedObserver.onChange(selfChange);
}
</code></pre>

<p>  }</p>

<p>  public void setEnabled(boolean isEnabled) {</p>

<pre><code>mIsEnabled = isEnabled;
</code></pre>

<p>  }
}
```</p>

<p>``` java
public class MyCursorLoader extends AbstractLoader<Cursor> {
  private final DisableableContentObserver mObserver;</p>

<p>  public MyCursorLoader(Context context) {</p>

<pre><code>super(context);
mObserver = new DisableableContentObserver(new ForceLoadContentObserver());
</code></pre>

<p>  }</p>

<p>  // bunch of setters for uri, projection, selection, etc. Omitted for brevity</p>

<p>  @Override
  protected void onStartLoading() {</p>

<pre><code>mObserver.setEnabled(true);
super.onStartLoading();
</code></pre>

<p>  }</p>

<p>  @Override
  protected void onAbandon() {</p>

<pre><code>mObserver.setEnabled(false);
</code></pre>

<p>  }</p>

<p>  @Override
  protected void onReset() {</p>

<pre><code>mObserver.setEnabled(false);
super.onReset();
</code></pre>

<p>  }</p>

<p>  @Override
  public Cursor loadInBackground() {</p>

<pre><code>Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection,
    mSelectionArgs, mSortOrder);
if (cursor != null) {
  // Ensure the cursor window is filled
  cursor.getCount();
}
return cursor;
</code></pre>

<p>  }</p>

<p>  @Override
  protected void onNewDataDelivered(Cursor data) {</p>

<pre><code>super.onNewDataDelivered(data);
data.registerContentObserver(mObserver);
</code></pre>

<p>  }
}
```</p>

<h2>AbstractObservingLoader</h2>

<p>The <code>CursorLoader</code> is a bit special case, because the <code>Cursor</code> itself contains <code>ContentObservable</code>. In most cases however the content observers and loaded data would be completely separated. For these cases it would be useful to have a base class for Loader which registers some <code>ContentObservers</code>:</p>

<p>``` java
public abstract class AbstractObservingLoader<T> extends AbstractLoader<T> {
  protected final DisableableContentObserver mObserver;
  private boolean mIsRegistered;</p>

<p>  public AbstractObservingLoader(Context context) {</p>

<pre><code>super(context);
mObserver = new DisableableContentObserver(new ForceLoadContentObserver());
</code></pre>

<p>  }</p>

<p>  @Override
  protected void onStartLoading() {</p>

<pre><code>mObserver.setEnabled(true);
super.onStartLoading();
</code></pre>

<p>  }</p>

<p>  @Override
  protected void onAbandon() {</p>

<pre><code>mObserver.setEnabled(false);
unregisterObserver(mObserver);
mIsRegistered = false;
</code></pre>

<p>  }</p>

<p>  @Override
  protected void onReset() {</p>

<pre><code>mObserver.setEnabled(false);
unregisterObserver(mObserver);
mIsRegistered = false;z
super.onReset();
</code></pre>

<p>  }</p>

<p>  @Override
  protected void onNewDataDelivered(T data) {</p>

<pre><code>if (!mIsRegistered) {
  mIsRegistered = true;
  registerObserver(mObserver);
}
</code></pre>

<p>  }</p>

<p>  protected abstract void registerObserver(ContentObserver observer);
  protected abstract void unregisterObserver(ContentObserver observer);
}
```</p>

<p>We need to keep the registered state in our Loader, because the default <code>Observable</code> implementation doesn&rsquo;t like registering the same observer twice or unregistering not registered observer.</p>

<p>Now we can use this class as a base for a Loader which should be reloaded when one of specified <code>Uri</code>s is triggered:</p>

<p>``` java
public class MyCursorLoader extends AbstractObservingLoader<Cursor> {</p>

<p>  public MyCursorLoader(Context context) {</p>

<pre><code>super(context);
</code></pre>

<p>  }</p>

<p>  // bunch of setters for uri, projection, selection, etc. Omitted for brevity</p>

<p>  @Override
  public Cursor loadInBackground() {</p>

<pre><code>Cursor cursor = getContext().getContentResolver().query(mUri, mProjection, mSelection,
    mSelectionArgs, mSortOrder);
if (cursor != null) {
  // Ensure the cursor window is filled
  cursor.getCount();
}
return cursor;
</code></pre>

<p>  }</p>

<p>  @Override
  protected void onNewDataDelivered(Cursor data) {</p>

<pre><code>super.onNewDataDelivered(data);
data.registerContentObserver(mObserver);
</code></pre>

<p>  }</p>

<p>  @Override
  protected void registerObserver(ContentObserver observer) {</p>

<pre><code>for (Uri uri : mObservedUris) {
  getContext().getContentResolver().registerContentObserver(uri, true, observer);
}
</code></pre>

<p>  }</p>

<p>  @Override
  protected void unregisterObserver(ContentObserver observer) {</p>

<pre><code>getContext().getContentResolver().unregisterContentObserver(observer);
</code></pre>

<p>  }
}
```</p>

<h2>Conclusions</h2>

<p>I think the <code>Loaders</code> aren&rsquo;t as bad as some people think and say. Four Loader states might seem complicated at first, but if you think about Android <code>Activity</code> lifecycle they make perfect sense and they are something you&rsquo;d have to implement yourself, with a high probability of mucking things up. The only thing lacking is documentation and sane base classes for extensions, something I hope I delivered through this blog post.</p>

<p><a href="https://plus.google.com/114205433913370454414">+CommonsWare</a> wrote few weeks ago that <a href="http://commonsware.com/blog/2014/03/31/cwac-loaderex-failed-abstractions.html">he considers Loader to be a failed abstraction</a>, mostly because the interface assumes there is a single object which notifies the Loader about new data. He concluded his post with the following sentence:</p>

<p><blockquote><p>In my case, if I am going to have some singleton manager object, with distinct data objects per operation, I am going to use something more flexible than Loader, such as an event bus.</p></blockquote></p>

<p>Extending <code>AbstractObservingLoader</code> to load some data from <code>SQLiteDatabase</code> and subscribe to some event bus for model change events should be trivial, and you&rsquo;d get a lot of things for free &ndash; performing loads in background, cancelling loads, caching results, invalidating cache, and so on.</p>

<p>Having said that, <code>Loaders</code> are not solution to every single problem. They are coupled with activity lifecycle, so they are not suitable for long running tasks that should not be interrupted when user navigates away. In these cases the <code>IntentService</code>, or some other <code>Service</code> implementation is a better choice.</p>
]]></content>
  </entry>
  
</feed>
