---
layout: post
comments: true
title: "Android: sync adapter lifecycle"
date: 2013-01-30T21:46:00+01:00
categories:
 - sync
 - Android
---

In [Android sticky broadcast perils](/blog/2012/09/26/android-sticky-broadcast-perils) I hinted that the [`ContentResolver.isSyncActive()`](http://developer.android.com/reference/android/content/ContentResolver.html#isSyncActive%28android.accounts.Account, java.lang.String%29) might not yield the results you'd expect. I described this issue in [the talk I gave during the KrakDroid 2012 conference](/blog/2012/12/18/krakdroid-aftermath), but the chances are you weren't there, so I decided to write a blog post about it.

[`ContentResolver`](http://developer.android.com/reference/android/content/ContentResolver.html) contains bunch of static methods with "sync" in their name: there is [`requestSync`](http://developer.android.com/reference/android/content/ContentResolver.html#requestSync%28android.accounts.Account, java.lang.String, android.os.Bundle%29) to start sync process, [`isSyncPending`](http://developer.android.com/reference/android/content/ContentResolver.html#isSyncPending%28android.accounts.Account, java.lang.String%29) and [`isSyncActive`](http://developer.android.com/reference/android/content/ContentResolver.html#isSyncActive%28android.accounts.Account, java.lang.String%29) for polling the sync state, [`addStatusChangeListener`](http://developer.android.com/reference/android/content/ContentResolver.html#addStatusChangeListener%28int, android.content.SyncStatusObserver%29) for listening for sync status and finally [`cancelSync`](http://developer.android.com/reference/android/content/ContentResolver.html#cancelSync%28android.accounts.Account, java.lang.String%29) for stopping the ongoing synchronization process. The list looks fine, in a sense that theoretically it's enough to implement the most sync-related functionality on the UI side. Let's see what is the relation between sync status reported by ContentResolver's sync methods and [`onPerformSync`](http://developer.android.com/reference/android/content/AbstractThreadedSyncAdapter.html#onPerformSync%28android.accounts.Account, android.os.Bundle, java.lang.String, android.content.ContentProviderClient, android.content.SyncResult%29) method in your [`SyncAdapter`](http://developer.android.com/reference/android/content/AbstractThreadedSyncAdapter.html).

After calling [`requestSync`](http://developer.android.com/reference/android/content/ContentResolver.html#requestSync%28android.accounts.Account, java.lang.String, android.os.Bundle%29), the sync for a given account and authority is added to the pending list, meaning that the sync will be executed as soon as possible (for example when syncs for other authorities are finished). In this state the [`isSyncPending`](http://developer.android.com/reference/android/content/ContentResolver.html#isSyncPending%28android.accounts.Account, java.lang.String%29) returns true, the [`SyncStatusObservers`](http://developer.android.com/reference/android/content/SyncStatusObserver.html) registered with [`SYNC_OBSERVER_TYPE_PENDING`](http://developer.android.com/reference/android/content/ContentResolver.html#SYNC_OBSERVER_TYPE_PENDING) mask will be triggered, and so on. This happens **before** your [`onPerformSync`](http://developer.android.com/reference/android/content/AbstractThreadedSyncAdapter.html#onPerformSync%28android.accounts.Account, android.os.Bundle, java.lang.String, android.content.ContentProviderClient, android.content.SyncResult%29) code is executed. Nothing especially surprising yet. The key point here is, you should take into consideration that your sync request might spend a lot of time in this state, especially if many other SyncAdapters are registered in the system. For example, it's a good idea to indicate this state somehow in the UI, otherwise your app might seem unresponsive.

{% img center /images/sync.png %}

When there are no other pending or active sync requests, your sync operation will move to active state. The `onPerformSync` will start executing in the background thread, [`SyncStatusObservers`](http://developer.android.com/reference/android/content/SyncStatusObserver.html) will trigger for both [`SYNC_OBSERVER_TYPE_ACTIVE`](http://developer.android.com/reference/android/content/ContentResolver.html#SYNC_OBSERVER_TYPE_ACTIVE) (because the sync request enters this state) and [`SYNC_OBSERVER_TYPE_PENDING`](http://developer.android.com/reference/android/content/ContentResolver.html#SYNC_OBSERVER_TYPE_PENDING) (because the sync request leaves this state) masks, [`isSyncPending`](http://developer.android.com/reference/android/content/ContentResolver.html#isSyncPending%28android.accounts.Account, java.lang.String%29) will return false, and [`isSyncActive`](http://developer.android.com/reference/android/content/ContentResolver.html#isSyncActive%28android.accounts.Account, java.lang.String%29) will return true. In the happy case, when the [`onPerformSync`](http://developer.android.com/reference/android/content/AbstractThreadedSyncAdapter.html#onPerformSync%28android.accounts.Account, android.os.Bundle, java.lang.String, android.content.ContentProviderClient, android.content.SyncResult%29) method will finish normally, the [`SyncStatusObservers`](http://developer.android.com/reference/android/content/SyncStatusObserver.html) for [`SYNC_OBSERVER_TYPE_ACTIVE`](http://developer.android.com/reference/android/content/ContentResolver.html#SYNC_OBSERVER_TYPE_ACTIVE) state will trigger again, and [`isSyncActive`](http://developer.android.com/reference/android/content/ContentResolver.html#isSyncActive%28android.accounts.Account, java.lang.String%29) will return false again. Booring.

The things get funny when the cancelSync is called during [`onPerformSync`](http://developer.android.com/reference/android/content/AbstractThreadedSyncAdapter.html#onPerformSync%28android.accounts.Account, android.os.Bundle, java.lang.String, android.content.ContentProviderClient, android.content.SyncResult%29) execution. The sync thread will be interrupted and the [`onSyncCancelled`](http://developer.android.com/reference/android/content/AbstractThreadedSyncAdapter.html#onSyncCanceled%28%29) method in `SyncAdapter` will be called. The [`SyncStatusObservers`](http://developer.android.com/reference/android/content/SyncStatusObserver.html) will trigger, [`isSyncActive`](http://developer.android.com/reference/android/content/ContentResolver.html#isSyncActive%28android.accounts.Account, java.lang.String%29) will return false and so on, and... at some point the [`onPerformSync`](http://developer.android.com/reference/android/content/AbstractThreadedSyncAdapter.html#onPerformSync%28android.accounts.Account, android.os.Bundle, java.lang.String, android.content.ContentProviderClient, android.content.SyncResult%29) method will finish execution.

Say what? Wasn't the sync thread interrupted? It was, but not in a "Bang, you're dead" way, but in a ["polite" way as described by Herb Sutter](http://www.drdobbs.com/parallel/interrupt-politely/207100682). All the stuff described in the [`Thread.interrupt`](http://developer.android.com/reference/java/lang/Thread.html#interrupt%28%29) happened, but in 99% of cases it means that the thread continues to execute as usual, except the [`interrupted`](http://developer.android.com/reference/java/lang/Thread.html#isInterrupted%28%29) flag is now set. To really support cancelling the sync thread you'd have to define an interruption points at which you'll check this flag and return early from [`onPerformSync`](http://developer.android.com/reference/android/content/AbstractThreadedSyncAdapter.html#onPerformSync%28android.accounts.Account, android.os.Bundle, java.lang.String, android.content.ContentProviderClient, android.content.SyncResult%29).

[{% img center http://twimgs.com/ddj/images/article/2008/0804/080401hs01_f1.gif %}](http://twimgs.com/ddj/images/article/2008/0804/080401hs01_f1.gif)
Things get even funnier here: when I used the [`isInterrupted`](http://developer.android.com/reference/java/lang/Thread.html#isInterrupted%28%29) method for polling the state of the sync thread, I got the bad case of heisenbug. In 9 cases out of 10 everything worked as expected, but every now and then the thread continued to execute even though earlier the [`onSyncCancelled`](http://developer.android.com/reference/android/content/AbstractThreadedSyncAdapter.html#onSyncCanceled%28%29) was called. I guess somewhere else the `InterruptedException` was caught and never rethrown or someone else was polling the sync thread with [`interrupted`](http://developer.android.com/reference/java/lang/Thread.html#interrupted%28%29) and cleared the flag. To pinpoint the root cause of this behavior I'd have to read through a lot of code, so instead I implemented my own flag and set it in [`onSyncCancelled`](http://developer.android.com/reference/android/content/AbstractThreadedSyncAdapter.html#onSyncCanceled%28%29) callback. Works like a charm.

Why is this an issue though? Can't we just let [`onPerformSync`](http://developer.android.com/reference/android/content/AbstractThreadedSyncAdapter.html#onPerformSync%28android.accounts.Account, android.os.Bundle, java.lang.String, android.content.ContentProviderClient, android.content.SyncResult%29) to finish in some undefined future? In most cases that's exactly the right way to think about this issue, but if the [`onPerformSync`](http://developer.android.com/reference/android/content/AbstractThreadedSyncAdapter.html#onPerformSync%28android.accounts.Account, android.os.Bundle, java.lang.String, android.content.ContentProviderClient, android.content.SyncResult%29) holds a lock on some resource like database handle, you might need to ensure that this lock is released as soon as possible after user cancels the sync.

**Recap**: show the sync pending state in the UI and if you really have to know when the sync has ended, do not trust the `ContentResolver` sync methods.
